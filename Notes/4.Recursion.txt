What is Recursion?

Recursion is a programming technique where a function calls itself to solve a problem in a smaller, more manageable way. It keeps breaking down the problem into smaller subproblems until it reaches a base case (a condition where it stops calling itself).


How Recursion Works (Step-by-Step)

1ï¸âƒ£ Base Case â†’ The condition that stops the recursion. Without this, the function would call itself infinitely.
2ï¸âƒ£ Recursive Case â†’ The part where the function calls itself with a smaller input.
3ï¸âƒ£ Stack Memory â†’ Each function call is stored in a call stack until the base case is reached, then the calls start resolving backwards.


Example 1: A Simple Recursive Function (Factorial)

Factorial of n (n!) is defined as:

using System;

class Program
{
    static int Factorial(int n)
    {
        if (n == 1)  // Base case
            return 1;
        
        return n * Factorial(n - 1);  // Recursive case
    }

    static void Main()
    {
        Console.WriteLine(Factorial(5)); // Output: 120
    }
}


âœ… How it works?

Factorial(5) â†’ 5 * Factorial(4)
Factorial(4) â†’ 4 * Factorial(3)
Factorial(3) â†’ 3 * Factorial(2)
Factorial(2) â†’ 2 * Factorial(1)
Factorial(1) â†’ 1 (Base case stops recursion)

The results start multiplying back up.

Why Use Recursion?

âœ… When a problem can be broken into smaller subproblems of the same type.
âœ… To simplify complex problems like tree traversals, sorting algorithms, and backtracking.
âœ… To reduce repetitive code that would be complicated with loops.


When Should You NOT Use Recursion?

ğŸš« When performance is a concern â†’ Recursion uses more memory (call stack).
ğŸš« When the problem can be solved easily using loops â†’ Iteration is often faster.
ğŸš« When recursion depth is too large â†’ Risk of stack overflow error.


Recursion vs Iteration

Feature			Recursion			Iteration (Loops)
===========================================================================

Memory Usage		High (stack calls)		Low
Speed			Slower (due to stack calls)	Faster
Code Simplicity		Often simpler			More complex for some problems
Best Use Cases		Tree/graph problems, sorting	Large repetitive tasks

Common Use Cases of Recursion

ğŸ“Œ Sorting Algorithms â†’ Merge Sort, Quick Sort
ğŸ“Œ Tree Traversals â†’ Preorder, Inorder, Postorder
ğŸ“Œ Graph Traversals â†’ Depth-First Search (DFS)
ğŸ“Œ Backtracking â†’ Sudoku solver, N-Queens problem
ğŸ“Œ Divide and Conquer Problems â†’ Binary search, Matrix multiplication



