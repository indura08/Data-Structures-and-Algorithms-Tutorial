1Ô∏è‚É£ What is a Hash Map / Hash Table? (Very basic)



A hash map is a data structure that stores key ‚Üí value pairs.



Example:



"name" ‚Üí "Indura"

"age"  ‚Üí 23

"id"   ‚Üí 1024





In TypeScript / JavaScript:



const user = new Map<string, any>();

user.set("name", "Indura");

user.set("age", 23);





Or with objects:



const user = {

&nbsp; name: "Indura",

&nbsp; age: 23

};



2Ô∏è‚É£ Why hash maps exist (the real reason)



Let‚Äôs say you have 1 million users.



Using an array:

users.find(u => u.id === 999999);





‚è± Time: O(n) (slow)



Using a hash map:

usersById.get(999999);





‚è± Time: O(1) (very fast)



üëâ Hash maps exist to find data instantly, without searching.



3Ô∏è‚É£ Why hash maps are so fast (core reason)

Short answer:



Hash maps convert keys into array indexes using a hash function.



That‚Äôs it.



4Ô∏è‚É£ How a hash map actually works (step by step)

Step 1: Key goes into hash function

hash("name") ‚Üí 324987



Step 2: Hash becomes array index

index = hash % arraySize



Step 3: Value stored at that index

table\[index] = value





So lookup becomes:



array\[index] ‚Üí DONE





No searching. No looping.



5Ô∏è‚É£ Why lookup is O(1)



Because:



Arrays give direct access



Hash maps secretly use arrays



Key ‚Üí index ‚Üí value



That‚Äôs constant time.



6Ô∏è‚É£ Hash map operations \& complexity



| Operation | Time |

| --------- | ---- |

| Insert    | O(1) |

| Search    | O(1) |

| Delete    | O(1) |



‚ö† Worst case: O(n) (rare, explained later)



7Ô∏è‚É£ What is a hash function (simple)



A hash function:



Takes a key



Converts it into a number



Tries to spread keys evenly



Good hash function:

‚úî Fast

‚úî Deterministic

‚úî Uniform distribution



8Ô∏è‚É£ Collisions (the downside)

What is a collision?



Two keys produce the same index.



hash("abc") % 10 = 3

hash("xyz") % 10 = 3



How collisions are handled

1Ô∏è‚É£ Chaining (most common)

table\[index] = \[ {key, value}, {key, value} ]





Linked list / array at each index.



2Ô∏è‚É£ Open addressing



Linear probing



Quadratic probing



Double hashing



(JS engines mostly use variations of these)



9Ô∏è‚É£ Why hash maps are still fast despite collisions



Because:



Good hash functions minimize collisions



Table resizes automatically



Load factor is controlled



üîü Load factor (important but simple)

load factor = number of items / table size





Example:



10 items / 20 slots = 0.5





If load factor gets high:



Table resizes



Rehashing happens



1Ô∏è‚É£1Ô∏è‚É£ Hash Map vs Object in TypeScript

Map



‚úî Preserves insertion order

‚úî Any key type

‚úî Faster for large data

‚úî Safer



Object



‚úî Simple

‚úî String/symbol keys only

‚ùå Prototype issues

‚ùå Less predictable performance



Senior rule:



Use Map for serious data structures



1Ô∏è‚É£2Ô∏è‚É£ Why hash maps are faster than trees \& arrays



| Structure          | Search Time |

| ------------------ | ----------- |

| Array              | O(n)        |

| Linked List        | O(n)        |

| Binary Search Tree | O(log n)    |

| Balanced Tree      | O(log n)    |

| \*\*Hash Map\*\*       | \*\*O(1)\*\*    |





1Ô∏è‚É£3Ô∏è‚É£ Data structures faster than hash maps?



‚ö† None for general key lookup



But in special cases:



1Ô∏è‚É£ Array (index-based)

arr\[5]





Faster than hash map only if index is known



2Ô∏è‚É£ Bitsets / Boolean arrays



Used in low-level systems



Memory-efficient



Very limited use case



3Ô∏è‚É£ Perfect hash tables (rare)



Used in compilers



No collisions



Static data only



1Ô∏è‚É£4Ô∏è‚É£ When NOT to use hash maps



‚ùå Need sorted order

‚ùå Need range queries

‚ùå Need min/max quickly



Use instead:



TreeMap / Red-Black Tree



Skip List



Heap



1Ô∏è‚É£5Ô∏è‚É£ Real-world usage of hash maps



Caches (Redis)



Databases (indexes)



Session storage



Authentication tokens



Counting frequencies



Deduplication



Graph adjacency lists



1Ô∏è‚É£6Ô∏è‚É£ Simple TypeScript example (frequency counter)

function countFrequency(arr: number\[]): Map<number, number> {

&nbsp;   const map = new Map<number, number>();



&nbsp;   for (const num of arr) {

&nbsp;       map.set(num, (map.get(num) ?? 0) + 1);

&nbsp;   }



&nbsp;   return map;

}



üîë Final mental model (memorize this)



Hash maps trade memory for speed.



They are:



Extremely fast



Not ordered



Not comparison-based



Used everywhere in production systems



