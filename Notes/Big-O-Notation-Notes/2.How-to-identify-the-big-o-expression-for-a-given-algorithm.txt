1ï¸âƒ£ Count the Number of Operations

Look at the number of times the main operations (loops, recursion, function calls) execute as n (input size) grows.


2ï¸âƒ£ Identify Patterns in the Code

If an operation happens once, itâ€™s O(1).
If a loop runs n times, itâ€™s O(n).
If a nested loop runs n Ã— n times, itâ€™s O(nÂ²).
If an algorithm divides the problem in half each step, itâ€™s O(log n).
If an algorithm doubles work every step, itâ€™s O(2â¿).

3ï¸âƒ£ Ignore Constants and Lower-Order Terms

Big O focuses on the largest growing factor (dominant term).

If your algorithm has O(3n + 5), you drop constants and write it as O(n).
If it's O(nÂ² + n), you ignore n and keep O(nÂ²).

ğŸ”¹ Example 2: Nested Loop â†’ O(nÂ²)

def print_pairs(n):
    for i in range(n):
        for j in range(n):
            print(i, j)  # Runs 'n * n' times

âœ… The outer loop runs n times.
âœ… The inner loop runs n times for each outer loop.
âœ… Total operations = n Ã— n = O(nÂ²).


ğŸ”¹ Example 3: Halving the Problem â†’ O(log n)

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1


âœ… The array shrinks by half each step â†’ O(log n).


Q: