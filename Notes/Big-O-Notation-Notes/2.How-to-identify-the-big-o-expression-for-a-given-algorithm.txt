1️⃣ Count the Number of Operations

Look at the number of times the main operations (loops, recursion, function calls) execute as n (input size) grows.


2️⃣ Identify Patterns in the Code

If an operation happens once, it’s O(1).
If a loop runs n times, it’s O(n).
If a nested loop runs n × n times, it’s O(n²).
If an algorithm divides the problem in half each step, it’s O(log n).
If an algorithm doubles work every step, it’s O(2ⁿ).

3️⃣ Ignore Constants and Lower-Order Terms

Big O focuses on the largest growing factor (dominant term).

If your algorithm has O(3n + 5), you drop constants and write it as O(n).
If it's O(n² + n), you ignore n and keep O(n²).

🔹 Example 2: Nested Loop → O(n²)

def print_pairs(n):
    for i in range(n):
        for j in range(n):
            print(i, j)  # Runs 'n * n' times

✅ The outer loop runs n times.
✅ The inner loop runs n times for each outer loop.
✅ Total operations = n × n = O(n²).


🔹 Example 3: Halving the Problem → O(log n)

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1


✅ The array shrinks by half each step → O(log n).


Q: