What is Big O Notation?
_________________________

Big O notation is a way to measure how fast or slow an algorithm is as the input size grows. Instead of measuring exact time, it gives a rough idea of how the algorithm scales when the input gets bigger.

Imagine youâ€™re ordering pizza:

ğŸ• Fastest case: The pizza place is right next door. (Best case scenario)
ğŸ• Average case: It takes the usual delivery time.
ğŸ• Worst case: The driver gets stuck in traffic. (Worst case scenario)

Big O focuses mostly on the worst case because we want to know the maximum time an algorithm might take.


Common Big O Complexities (with Examples)
__________________________________________

Here are some common time complexities with real-life examples:

1ï¸âƒ£ O(1) - Constant Time
---------------------

ğŸš€ Super fast! The time doesnâ€™t change no matter how big the input is.
Example: Looking at the first item in a list.

Code Example

def get_first_item(arr):
    return arr[0]  # Always takes the same time


2ï¸âƒ£ O(log n) - Logarithmic Time
---------------------------

ğŸ” Efficient! The time grows slowly as input increases.
Example: Searching in a sorted phone book (Binary Search).

Code Example:

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1


3ï¸âƒ£ O(n) - Linear Time
-------------------

ğŸƒâ€â™‚ï¸ Gets slower as input grows.
Example: Checking all names in a guest list.

Code Example

def find_item(arr, target):
    for item in arr:
        if item == target:
            return True
    return False


4ï¸âƒ£ O(nÂ²) - Quadratic Time
---------------------------

ğŸ¢ Very slow for large inputs.
Example: Comparing every student with every other student in a class.

Code Example

def print_pairs(arr):
    for i in range(len(arr)):
        for j in range(len(arr)):
            print(arr[i], arr[j])


5ï¸âƒ£ O(2â¿) - Exponential Time
-----------------------------

ğŸš¨ Extremely slow! Avoid if possible.
Example: Trying all combinations in a password.

Code Example


def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)


Practice Exercise

Try guessing the Big O for these:

1ï¸âƒ£ Looping through an array once?
2ï¸âƒ£ Nested loops (loop inside another loop)?
3ï¸âƒ£ Binary Search on a sorted list?


what is O and what is the meant by mathematical expression?
____________________________________________________________

1ï¸âƒ£ What is "O" in Big O Notation?

The "O" in Big O notation stands for "Order of", which means how fast an algorithm grows as the input size increases.

ğŸ’¡ Think of "O" as a way to say "at most this fast" or "upper bound" of an algorithmâ€™s growth.



2ï¸âƒ£ What Goes Inside the Brackets "O(...)"?

Inside the brackets, we put a mathematical expression that represents how the number of operations increases with n (input size).

Hereâ€™s what each one means:

1. O(1) â†’ Constant Time

ğŸ“Œ No matter how big n is, the number of operations stays the same.
Example: Looking at the first item in an array.


2. O(n) â†’ Linear Time

ğŸ“Œ Operations increase directly with n.
Example: Looping through an array

3. O(log n) â†’ Logarithmic Time

ğŸ“Œ Each step reduces the problem size (cuts it in half).

Example: Binary Search (searching in a sorted list)


O(nÂ²) â†’ Quadratic Time

ğŸ“Œ Operations grow exponentially as n grows.

Example: Nested loops (checking all pairs).




