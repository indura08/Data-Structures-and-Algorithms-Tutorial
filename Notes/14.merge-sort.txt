1Ô∏è‚É£ What Is Merge Sort? (Plain English)

Merge Sort is a divide-and-conquer sorting algorithm.

It repeatedly splits the array into smaller parts, sorts those parts, and then merges them back together in sorted order.

Key idea:

Small problems are easy to solve; combine their solutions to solve the big problem.

2Ô∏è‚É£ The Core Strategy: Divide & Conquer

Merge Sort follows three steps:

Divide the array into two halves

Conquer by recursively sorting each half

Merge the two sorted halves

This happens recursively until each subarray has one element.

3Ô∏è‚É£ Why Merge Sort Works (Intuition)

A single element is already sorted.

So if we:

Break the array down into single elements

Then merge them in sorted order

üëâ The entire array becomes sorted.

4Ô∏è‚É£ Visual Walkthrough

Array:

[38, 27, 43, 3, 9, 82, 10]

Step 1 ‚Äî Divide
[38, 27, 43]   [3, 9, 82, 10]

Step 2 ‚Äî Divide again
[38] [27, 43]   [3, 9] [82, 10]

Step 3 ‚Äî Divide until size = 1
[27] [43]
[82] [10]

Step 4 ‚Äî Merge
[27, 43]
[10, 82]

Step 5 ‚Äî Merge again
[27, 38, 43]
[3, 9, 10, 82]

Step 6 ‚Äî Final merge
[3, 9, 10, 27, 38, 43, 82]

5Ô∏è‚É£ Algorithm Steps (Formal)

If array length ‚â§ 1 ‚Üí return array

Split array into left and right halves

Recursively sort both halves

Merge sorted halves into one sorted array

6Ô∏è‚É£ Merge Function (The Heart of Merge Sort)

This is the most important part.

How merging works:

Compare the first elements of both arrays

Move the smaller one into the result

Continue until one array is empty

Append remaining elements

7Ô∏è‚É£ Correct Merge Sort (TypeScript)
Merge Function
function merge(left: number[], right: number[]): number[] {
    const result: number[] = [];
    let i = 0, j = 0;

    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }

    return result.concat(left.slice(i)).concat(right.slice(j));
}

Merge Sort Function
function mergeSort(array: number[]): number[] {
    if (array.length <= 1) return array;

    const mid = Math.floor(array.length / 2);
    const left = mergeSort(array.slice(0, mid));
    const right = mergeSort(array.slice(mid));

    return merge(left, right);
}

8Ô∏è‚É£ Time Complexity (Very Important)

| Case    | Time       |
| ------- | ---------- |
| Best    | O(n log n) |
| Average | O(n log n) |
| Worst   | O(n log n) |
9Ô∏è‚É£ Why O(n log n)?

log n levels of recursion (halving)

n work at each level (merging)

ùëõ
√ó
log
‚Å°
ùëõ
n√ólogn
üîü Space Complexity

O(n) extra space

Uses additional arrays

üìå This is the main downside.

1Ô∏è‚É£1Ô∏è‚É£ Stability

‚úÖ Stable

Because:

Equal elements keep their relative order

Left element is chosen first when equal

| Feature    | Insertion | Merge      |
| ---------- | --------- | ---------- |
| Time       | O(n¬≤)     | O(n log n) |
| Space      | O(1)      | O(n)       |
| Stability  | ‚úÖ         | ‚úÖ          |
| Adaptive   | ‚úÖ         | ‚ùå          |
| Large data | ‚ùå         | ‚úÖ          |


1Ô∏è‚É£3Ô∏è‚É£ Where Merge Sort Is Used in Industry
‚úî Used when:

Large datasets

Stable sort required

Linked lists

External (disk-based) sorting

Parallel processing

‚úî Used by:

Databases

Big data systems

Distributed systems

MapReduce

1Ô∏è‚É£4Ô∏è‚É£ Why Merge Sort Is Perfect for Linked Lists

Because:

Splitting is cheap

No random access needed

No extra array copying

1Ô∏è‚É£5Ô∏è‚É£ Merge Sort vs Quick Sort (Preview)

| Merge Sort              | Quick Sort         |
| ----------------------- | ------------------ |
| Stable                  | ‚ùå                  |
| Guaranteed O(n log n)   | Worst O(n¬≤)        |
| Uses extra space        | In-place           |
| Good for large datasets | Faster in practice |

1Ô∏è‚É£6Ô∏è‚É£ Common Mistakes

‚ùå Forgetting base case
‚ùå Incorrect merge logic
‚ùå Losing elements while merging
‚ùå Thinking it‚Äôs in-place

1Ô∏è‚É£7Ô∏è‚É£ Mental Model (Memorize This)

‚ÄúBreak everything down until it‚Äôs trivial,
then rebuild it in order.‚Äù

1Ô∏è‚É£8Ô∏è‚É£ Senior Engineer Insight üí°

Merge Sort trades memory for predictability.

That‚Äôs why it‚Äôs used where worst-case performance matters.

1Ô∏è‚É£9Ô∏è‚É£ Interview One-Liner

Merge Sort is a stable, divide-and-conquer sorting algorithm with guaranteed O(n log n) time complexity and O(n) space complexity.
