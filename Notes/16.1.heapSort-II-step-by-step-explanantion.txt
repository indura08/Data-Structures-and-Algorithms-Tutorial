1️⃣ First, what exactly are we trying to do in Phase 1?

Phase 1 goal:

Convert a normal array into a Max Heap

That means:

Every parent index must be greater than its children

We will fix the array from bottom to top

2️⃣ Important rule (this is the key)

In a heap stored as an array:

left child  = 2*i + 1
right child = 2*i + 2

This rule alone explains everything.

3️⃣ What is a “leaf node” in array terms?

A leaf node is an index that:

has NO children

meaning:

2*i + 1 >= n


If left child index is outside the array, that index is a leaf.

4️⃣ Why leaf nodes do NOT need heapify

Heapify does this:

Compare parent with children

Swap if needed

But leaf nodes:

Have no children

Nothing to compare

Already valid heaps

✅ So heapify on leaf nodes is useless


5️⃣ So where do leaf nodes start?

Let’s calculate.

We want:

2*i + 1 >= n


Solve for i:

2*i >= n - 1
i >= (n - 1) / 2


So:

All indexes ≥ floor(n/2) are leaf nodes

6️⃣ Therefore…

Indexes that actually need heapify are:

0  → first parent
1
2
...
floor(n/2) - 1 → LAST parent


That’s it.

7️⃣ This is why we start at:

Math.floor(n / 2) - 1


Because:

That index is the last parent

Everything after it is a leaf

Heapify must start from the last parent upward

8️⃣ Concrete example (very important)

Array:

[4, 10, 3, 5, 1]


Indexes:

0  1   2  3  4


Length:

n = 5


Calculate:

Math.floor(5 / 2) - 1
= 2 - 1
= 1


So we start heapify at index 1, then 0

Check index 1:
left  = 2*1 + 1 = 3
right = 2*1 + 2 = 4


Valid children → heapify needed

Check index 2:
left = 2*2 + 1 = 5 ❌ (out of bounds)


So index 2 is a leaf → skip


