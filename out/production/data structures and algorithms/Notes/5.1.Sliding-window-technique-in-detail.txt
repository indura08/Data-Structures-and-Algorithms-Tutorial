ğŸªŸ What is the Sliding Window Technique?
----------------------------------------

ğŸ§  Imagine this:
You have a big list of numbers, and youâ€™re interested in looking at a fixed number of them at a time, like looking through a small window that moves across the list.

ğŸ’¡ The "window" is just a small group of elements.

We slide this window forward (one step at a time), and do something with the numbers inside the window â€” like:

Calculate their sum

Find their max/min

Count how many even numbers, etc.

ğŸ“¦ Real-world Analogy:
-------------------------

Think of watching a train through a small window:

The window can only show 3 people at a time.

As the train moves, 1 person goes out of view and 1 new person comes into view.

You keep updating what you see without restarting every time.


ğŸ§ª Basic Sliding Window Problem Example (with code)
-----------------------------------------------------

â“ Problem:
"Given an array of integers and a number k, return the maximum sum of any subarray of size k."

ğŸ’­ Example:

Array: [2, 1, 5, 1, 3, 2]
k = 3

We want the maximum sum of any 3 consecutive elements.

Letâ€™s look at all possible 3-number windows:

[2, 1, 5] â†’ sum = 8

[1, 5, 1] â†’ sum = 7

[5, 1, 3] â†’ sum = 9 âœ…

[1, 3, 2] â†’ sum = 6

ğŸ‘‰ So the answer is 9


ğŸ’¡ How does the code do this efficiently?
-------------------------------------------

If we calculate sum for every subarray from scratch, it takes a lot of time.
Instead, we use sliding window:

Calculate the first window sum (first 3 numbers).

Then, slide the window one step:

Subtract the number going out

Add the number coming in

âœ… Java Code (with comments)

public int maxSum(int[] nums, int k) {
    int maxSum = 0;
    int windowSum = 0;

    // Step 1: Calculate sum of first window
    for (int i = 0; i < k; i++) {
        windowSum += nums[i];
    }

    maxSum = windowSum;

    // Step 2: Slide the window from left to right
    for (int i = k; i < nums.length; i++) {
        // Subtract the number that is going out of the window
        windowSum = windowSum - nums[i - k];

        // Add the number that is coming into the window
        windowSum = windowSum + nums[i];

        // Update max if needed
        maxSum = Math.max(maxSum, windowSum);
    }

    return maxSum;
}


ğŸ”„ What happens step-by-step?
------------------------------

For array: [2, 1, 5, 1, 3, 2] and k = 3

First window: 2 + 1 + 5 = 8

Slide:

Remove 2, add 1 â†’ new window [1, 5, 1] â†’ sum = 7

Remove 1, add 3 â†’ [5, 1, 3] â†’ sum = 9

Remove 5, add 2 â†’ [1, 3, 2] â†’ sum = 6

Weâ€™re just reusing the previous windowâ€™s sum, making it faster.


ğŸ¤¯ Why is this better than a normal loop?
------------------------------------------

âŒ Brute force (slow way):
Nested loops â†’ O(n Ã— k) time

âœ… Sliding window (smart way):
One loop â†’ O(n) time

Youâ€™re avoiding repeating the same addition over and over.

ğŸ”„ Sliding Window Variants
----------------------------

You can use sliding window in:

Fixed-size windows â†’ like above (k is fixed)

Variable-size windows â†’ like finding the smallest subarray with sum â‰¥ target

Strings â†’ e.g., longest substring with no repeating characters



